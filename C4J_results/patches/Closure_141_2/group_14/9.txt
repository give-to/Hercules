src/com/google/javascript/jscomp/ExpressionDecomposer.java:696:replace:0,53$if ((isSafeAssign(parent, seenSideEffects)) && (isConditionalOp(parent))) {} else {for (Node n : parent.children()) {if (n == child) {break;}if (isExpressionTreeUnsafe(n, seenSideEffects)) {seenSideEffects = true;requiresDecomposition = true;}}Node first = parent.getFirstChild();if (requiresDecomposition&& parent.getType() == Token.CALL&& NodeUtil.isGet(first)) {if (maybeExternMethod(first)) {return DecompositionType.UNDECOMPOSABLE;} else {return DecompositionType.DECOMPOSABLE;}}}
src/com/google/javascript/jscomp/ExpressionDecomposer.java:752:replace:0,53$for ( Node parent : child . getAncestors ( ) ) { if ( ( parent == expressionRoot ) { / / Done . The walk back to the root of the expression is complete , and / / nothing was encountered that blocks the call from being moved . return requiresDecomposition ? DecompositionType . DECOMPOSABLE : DecompositionType . MOVABLE ; } int parentType = parent . getType ( ) ; if ( isConditionalOp ( parent ) ) { / / Only the first child is always executed , otherwise it must be / / decomposed . if ( child != parent . getFirstChild ( ) ) { requiresDecomposition = true ; } } else { / / Only inline the call if none of the preceding siblings in the / / expression have side - effects , and are unaffected by the side - effects , / / if any , of the call in question . / / NOTE : This depends on the siblings being in the same order as they / / are evaluated . / / SPECIAL CASE : Assignment to a simple name if ( isSafeAssign ( parent , seenSideEffects ) ) && ( isConditionalOp ( parent ) ) ) { } else { for      ( Node n : parent . children ( ) ) { if ( n == child ) { break ; } if ( isExpressionTreeUnsafe ( n , seenSideEffects ) ) { seenSideEffects = true ; requiresDecomposition = true ; } } Node first = parent . getFirstChild ( ) ; if             ( requiresDecomposition & & parent . getType ( ) == Token                    . CALL & & NodeUtil                . isGet   ( first ) ) { if ( maybeExternMethod ( first ) ) { return DecompositionType . UNDECOMPOSABLE ; } else { return DecompositionType . DECOMPOSABLE     ;            }                                               }                   }                                                                                                                                                                                                                                                                } / / Continue looking up the expression tree . child = parent ; }
src/com/google/javascript/jscomp/ExpressionDecomposer.java:682:replace:0,53$if ( ( isConditionalOp ( parent ) ) { / / Only the first child is always executed , otherwise it must be / / decomposed . if ( child != parent . getFirstChild ( ) ) { requiresDecomposition = true ; } } else { / / Only inline the call if none of the preceding siblings in the / / expression have side - effects , and are unaffected by the side - effects , / / if any , of the call in question . / / NOTE : This depends on the siblings being in the same order as they / / are evaluated . / / SPECIAL CASE : Assignment to a simple name if ( isSafeAssign ( parent , seenSideEffects ) ) && ( isConditionalOp ( parent ) ) ) { } else { for      ( Node n : parent . children ( ) ) { if ( n == child ) { break ; } if ( isExpressionTreeUnsafe ( n , seenSideEffects ) ) { seenSideEffects = true ; requiresDecomposition = true ; } } Node first = parent . getFirstChild ( ) ; if             ( requiresDecomposition & & parent . getType ( ) == Token                    . CALL & & NodeUtil                . isGet   ( first ) ) { if ( maybeExternMethod ( first ) ) { return DecompositionType . UNDECOMPOSABLE ; } else { return DecompositionType . DECOMPOSABLE     ;            }                                               }                   }                                                                                                                                                                                                                                                                }
src/com/google/javascript/jscomp/ExpressionDecomposer.java:671:replace:0,53$for ( Node parent : child . getAncestors ( ) ) { if ( ( parent == expressionRoot ) { / / Done . The walk back to the root of the expression is complete , and / / nothing was encountered that blocks the call from being moved . return requiresDecomposition ? DecompositionType . DECOMPOSABLE : DecompositionType . MOVABLE ; } int parentType = parent . getType ( ) ; if ( isConditionalOp ( parent ) ) { / / Only the first child is always executed , otherwise it must be / / decomposed . if ( child != parent . getFirstChild ( ) ) { requiresDecomposition = true ; } } else { / / Only inline the call if none of the preceding siblings in the / / expression have side - effects , and are unaffected by the side - effects , / / if any , of the call in question . / / NOTE : This depends on the siblings being in the same order as they / / are evaluated . / / SPECIAL CASE : Assignment to a simple name if ( isSafeAssign ( parent , seenSideEffects ) ) && ( isConditionalOp ( parent ) ) ) { } else { for      ( Node n : parent . children ( ) ) { if ( n == child ) { break ; } if ( isExpressionTreeUnsafe ( n , seenSideEffects ) ) { seenSideEffects = true ; requiresDecomposition = true ; } } Node first = parent . getFirstChild ( ) ; if             ( requiresDecomposition & & parent . getType ( ) == Token                    . CALL & & NodeUtil                . isGet   ( first ) ) { if ( maybeExternMethod ( first ) ) { return DecompositionType . UNDECOMPOSABLE ; } else { return DecompositionType . DECOMPOSABLE     ;            }                                               }                   }                                                                                                                                                                                                                                                                } / / Continue looking up the expression tree . child = parent ; }
