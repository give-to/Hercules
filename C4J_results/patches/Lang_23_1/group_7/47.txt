src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java:158:replace:0,36$applyPattern(pattern);
src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java:159:replace:0,36$applyPattern(pattern);
src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java:209:replace:0,36$/ * * * Apply the specified pattern . * * @param pattern String * / @Override public final void applyPattern ( String pattern ) { if ( registry == null ) { super . applyPattern ( pattern ) ; toPattern = super . toPattern ( ) ; return ; } ArrayList < Format > foundFormats = new ArrayList < Format > ( ) ; ArrayList < String > foundDescriptions = new ArrayList < String > ( ) ; StringBuilder stripCustom = new StringBuilder ( pattern . length ( ) ) ; ParsePosition pos = new ParsePosition ( 0 ) ; char [ ] c = pattern . toCharArray ( ) ; int fmtCount = 0 ; applyPattern ( pattern    )                                  ;                                                                                                                                                                                                                                 super . applyPattern ( stripCustom . toString ( ) ) ; toPattern = insertFormats ( super . toPattern ( ) , foundDescriptions ) ; if ( containsElements ( foundFormats ) ) { Format [ ] origFormats = getFormats ( ) ; / / only loop over what we know we have , as MessageFormat on Java 1 . 3 / / seems to provide an extra format element : int i = 0 ; for ( Iterator < Format > it = foundFormats . iterator ( ) ; it . hasNext ( ) ; i + + ) { Format f = it . next ( ) ; if ( f != null ) { origFormats [ i ] = f ; } } super . setFormats ( origFormats ) ; } }
